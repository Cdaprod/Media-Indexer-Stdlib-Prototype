name: CI-Go-Quality-Gates

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  pull_request:
    paths:
      - "host/services/**"
      - "go.mod"
      - "go.sum"
      - "**/*.go"
  push:
    branches: ["**"]
    paths:
      - "host/services/**"
      - "go.mod"
      - "go.sum"
      - "**/*.go"
  workflow_dispatch:

jobs:
  go-qg:
    name: Lint â€¢ Vet â€¢ Vulnerabilities â€¢ Test (bounded) â€¢ Coverage
    runs-on: ubuntu-latest
    env:
      GO_VERSION: "1.22.x"
      GOFLAGS: "-trimpath -buildvcs=true -p=2"
      GOMAXPROCS: "2"
      # Only run -race on main and tags
      ENABLE_RACE: ${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')) && '1' || '0' }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          check-latest: true
          cache: true

      # Build cache only (module cache is handled by setup-go cache=true)
      - uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-gobuild-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-gobuild-

      - name: Ensure Go bin on PATH
        run: echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Enforce formatting (gofmt -s)
        run: |
          files=$(gofmt -s -l . | grep -E '\.go$' || true)
          if [ -n "$files" ]; then
            echo "These files need 'gofmt -s':"
            echo "$files"
            exit 1
          fi

      - name: Per-module staticcheck â€¢ vet â€¢ errcheck â€¢ govulncheck â€¢ tests
        shell: bash
        run: |
          set -euo pipefail

          # Tools needed for checks
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install github.com/kisielk/errcheck@latest
          go install golang.org/x/vuln/cmd/govulncheck@latest

          echo "mode: atomic" > coverage.out
          RACE_FLAG=""
          [ "${ENABLE_RACE}" = "1" ] && RACE_FLAG="-race"

          # Find all modules, excluding vendored ones
          mapfile -t MODS < <(git ls-files '**/go.mod' | grep -v '/vendor/')

          for mod in "${MODS[@]}"; do
            MODDIR="$(dirname "$mod")"
            echo "ðŸ”Ž Module: $MODDIR"

            pushd "$MODDIR" >/dev/null

            echo "â€¢ staticcheck"
            staticcheck ./...

            echo "â€¢ go vet"
            go vet ./...

            echo "â€¢ errcheck"
            errcheck ./...

            echo "â€¢ govulncheck"
            # best-effort; do not fail CI on vuln metadata outages
            govulncheck ./... || echo "govulncheck returned non-zero; continuing"

            echo "â€¢ go test (bounded)"
            go test ./... \
              $RACE_FLAG \
              -timeout=8m \
              -count=1 \
              -shuffle=on \
              -coverprofile=mod.cov \
              -covermode=atomic \
              -p=2 \
              -parallel=2

            # Merge coverage (skip header)
            if [ -f mod.cov ]; then
              tail -n +2 mod.cov >> "${GITHUB_WORKSPACE}/coverage.out"
              rm -f mod.cov
            fi

            popd >/dev/null
          done

      - name: Upload coverage to summary
        run: |
          go tool cover -func=coverage.out | tee coverage.txt
          pct=$(awk '/total:/ {gsub("%","",$3); print $3}' coverage.txt)
          echo "## Coverage" >> $GITHUB_STEP_SUMMARY
          printf '```\n%s\n```\n' "$(cat coverage.txt)" >> $GITHUB_STEP_SUMMARY
          awk -v PCT="$pct" 'BEGIN { if (PCT < 60.0) exit 1 }'

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage
          path: |
            coverage.out
            coverage.txt